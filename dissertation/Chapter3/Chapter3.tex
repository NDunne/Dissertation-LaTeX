% !TEX root =  ../report.tex

\section{Specification}
\label{s:spec}
The implementation will require work in two main areas: The Python code generation script, and in the OP2 library itself which is implemented in both C and Fortran. Only the C library will be modified, due to developer familiarity. OP2 does also include code generation using MatLab, but Python is more preferable recently, due to its flexibility, and it's conveniant string manipulation capabilities.
\par
The Python script will perform source-to-source translation. As input it will take the application files, which specify the structure of the program: declaring variables, and indicating where the loops parallelised by OP2 should be executed; and a kernel descriptor for each loop, which will describe the operation to be performed on each element of the set passed to the loop as a parameter. OP2 makes an important restriction that the order in which elements are processed must not affect the final result, to within the limits of finite precision floating-point arithmetic\cite[p3]{op2main}. This constraint allows the code generator freedom to not consider the ordering of iterations, and select an ordering based on performance.
\par
From this a set of valid C files must be generated, to be compiled by a normal C compiler. In the case of this project the compiler will be the NVidia C Compiler (\textit{nvcc}), as the code generated will be include CUDA.
\par
It is important that the resulting executable compiled from the generated code produces outputs within some tolerance of the outputs generated by execting parallel loop iterations sequentially. Correctness is always a priority over performance for any compiler.
\par
Furthermore, it will be ensured that the OP2 API is not be altered by any modifications to the library, to ensure that all exisiting programs using the API are able to seemless use the updated version.

\subsection{Runtime Assertions}
As discussed in Section \ref{sec:rw_JIT} on Just-In-Time Compilation, the performance gain from this optimisation technique comes from making assertions at runtime which can only be made once the input is known. The application's input will be a mesh over which to operate, which includes a large amount of data, and opens up a number of runtime optimisations. The primary target for this project is "Constant Definition": turning values specified in the input as constants into \verb|#define| directives for the C-Preprocessor. Other possible optimisations will be discussed in Section \ref{s:fw}, Future Work.

\subsection{System Model}
\begin{figure}[h!]
  \centering
  \begin{tikzpicture}[node distance=3cm, auto]
    \node [file] (source) {Source Files};
    \node [block, below of=source] (op2py) {CodeGen script};
    \node [file, right of=op2py, text width=6em] (sourceOp) {Modified Application Files};
    \node [file, above of=sourceOp] (Kernels) {Kernels};
    \node [jfile, below of=sourceOp] (recKernels) {Optimised Kernels};
    \node [block, right of=sourceOp] (aot) {AOT Compiler};

    \node [rbin, right of=aot] (binary) {Program Binary};
    \node [rfile, above of=binary] (input) {Input Map};
    \node [jfile, below of=binary] (consts) {Constants};
    \node [jblock, below of=consts] (jit) {JIT Compiler};
    \node [jbin, right of= consts] (so) {Shared Object};
    \node [rblock, right of=binary] (result) {Program Result};

    \tikzset{dotted box1/.style={draw=black!100, line width=2pt, dash pattern=on 4pt off 4pt,
      inner sep=4mm, rectangle, rounded corners}};

    \tikzset{dotted box2/.style={draw=black!40, line width=2pt, dash pattern=on 4pt off 4pt,
      inner sep=2mm, rectangle, rounded corners}};

    \node (runtime) [dotted box1, fit = (input) (jit) (result), color=green!50!black] {};
    \node (jitbox) [dotted box2, fit = (recKernels) (so) (jit), color=red!50!black] {};

    \node at (runtime.north east) [below left=2mm] (rtbox) {\textbf{Runtime}};
    \node at (jitbox.south west) [above right=2mm] (corner) {\textbf{OP2 "JIT"}};

    \path [line,line width=2pt, color=blue!50!black] (source) -- (op2py);
    \path [line, line width=2pt, color=red!70!black] (op2py) -- (recKernels);
    \path [line, line width=2pt, color=blue!50!black] (op2py) -- (sourceOp);
    \path [line, line width=2pt, color=blue!50!black] (op2py) -- (Kernels);
    \path [line,line width=2pt, color=blue!50!black] (sourceOp) -- (aot);
    \path [line,line width=2pt, color=blue!50!black] (Kernels) -- (aot);
    \path [line, line width=2pt, color=green!50!black] (aot) -- (binary);
    \path [line,line width=2pt, color=green!50!black] (input) -- (binary);
    \path [line,line width=2pt, color=green!50!black] (binary) -- (consts);
    \path [line,line width=2pt, color=red!70!black] (recKernels) |- (jit);
    \path [line,line width=2pt, color=green!50!black] (consts) -- (jit);
    \path [line, line width=2pt, color=green!50!black] (jit) -| (so);
    \path [line,line width=2pt, color=green!50!black] (so) -- (binary);
    \path [line, line width=2pt, color=green!50!black] (binary) -- (result);

  \end{tikzpicture}
  \caption{OP2 System Diagram with JIT Addition}
  \label{fig:jit_sys}
\end{figure}

Figure \ref{fig:jit_sys} describes the new workflow of the OP2 library, with the addition of Just-In-Time compilation. As before, code generation takes the application and loop files as input, and generates the Kernels and Modified Application Files. It also generates Optimised Kernels, where the code will only compile once the constants are known and defined by the pre-processor. These Kernel files are not used by the ahead of time compiler.

The OP2 API function:
\begin{center}
\lstinline{void op_decl_const(int dim, char *type, T *dat, char *name)}
\\\vspace{-1em}
\hspace*{\fill}\cite[p9]{manual}
\end{center}
\vspace{-1em}
Will be modified so that when called by the Program Binary it will generate a header file, where each of the constant values is added as a C \verb|#define| directive, where previously it needed to copy these values to the GPU device's memory.
\par At runtime, the executable invokes the \textit{nvcc} compiler again, to compile the Optimised Kernels which semantically include the constants header file, and link them into a Shared Object (Dynamically Loaded Library). This object is then loaded by the running executable, and the functions it provides are used instead of the unoptimised versions.
