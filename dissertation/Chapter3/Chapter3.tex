% !TEX root =  ../report.tex

\section{Specification}
\label{s:spec}

In order to clearly explain the new system with the addition that will be made to the OP2 framework, it is important to first describe the exisiting work-flow.

\subsection{Existing System}
\begin{figure}[h!]
\makebox[\textwidth][c]{
 \resizebox{1.2\textwidth}{!}{
  \begin{tikzpicture}[node distance=4cm, auto]
    \node [file] (source) {Source Files};
    \node [block, below of=source] (op2py) {CodeGen script};
    \node [file, right of=op2py, text width=6em] (sourceOp) {Modified Application File};
    \node [file, above of=sourceOp] (Kernels) {Kernels};
    \node [wblock, right of=sourceOp] (aot) {AOT Compiler};
    \node [wfile, below of=aot] (op2lib) {OP2 Library Files};

    \node [rbin, right of=aot] (binary) {Program Binary};
    \node [rfile, above of=binary] (input) {Input Map};
    \node [rblock, right of=binary] (result) {Program Result};

    \tikzset{dotted box1/.style={draw=black!100, line width=2pt, dash pattern=on 4pt off 4pt,
      inner sep=8mm, rectangle, rounded corners}};

    \node (run-time) [dotted box1, fit = (input) (result), color=green!50!black] {};
    \node at (run-time.north east) [above left=2mm] (rtbox) {\textbf{Run-time}};

    \node (code-gen) [dotted box1, fit = (source) (sourceOp), color=blue!50!black] {};
    \node at (code-gen.north west) [above right=2mm] (rtbox) {\textbf{Code Generation}};

    \path [line,line width=2pt, color=blue!50!black] (source) -- (op2py);
    \path [line, line width=2pt, color=blue!50!black] (op2py) -- (sourceOp);
    \path [line, line width=2pt, color=blue!50!black] (op2py) -- (Kernels);
    \path [line,line width=2pt, color=blue!50!black] (sourceOp) -- (aot);
    \path [line,line width=2pt, color=blue!50!black] (Kernels) -- (aot);
    \path [line,line width=2pt, color=black] (op2lib) -- (aot);
    \path [line, line width=2pt, color=green!50!black] (aot) -- (binary);
    \path [line,line width=2pt, color=green!50!black] (input) -- (binary);
    \path [line, line width=2pt, color=green!50!black] (binary) -- (result);

  \end{tikzpicture}
  }}
  \caption{OP2 System Diagram}
  \label{fig:aot_sys}
\end{figure}
The pre-exisiting OP2 workflow is shown in Figure \ref{fig:aot_sys}. In this system the Source Files are comprised of a master application file, which contains the OP2 API calls for definition of sets, maps, constants, and the structure of the application; as well as optional header files containing the operation to be the contents of each parallel loop.
\par
This forms the input to the code generation Python script, from which the output is a modified version of the master appliation file, and a kernel file for each parallel loop. These are compiled, and linked against the OP2 library for the desired hardware platform to produce the executable Program Binary. The expectation is that this binary will execute on the target hardware, taking a map as an input to produce the result desired by the application programmer.
\par
The existing system is able to generate optimised code for the target platform from the high level application code, and apply compiler optimisations ahead of time, including optimisations like \verb|-O3| and \verb|--use_fast_math|. It is not, however, able to optimise based on the inputs at all. This is where the implementation for this project comes in: to provide the ability to use the input data when optimising.
\vspace{-1.5cm}
\subsection{New System}
The implementation will require work in two main areas: the Python code generation script, and the OP2 library itself which is implemented in both C and Fortran. Only the C library will be modified, due to developer familiarity with C. OP2 does also include code generation using MatLab. The Python script is preferable, due to its flexibility and conveniant string manipulation capabilities.
\par
The Python script will need to perform the similar source-to-source translation to the pre-exisiting code generation script, but modified to generate modified code that will be compiled at run-time as well as the code that is compiled ahead of time. These must of course be valid C files, to be compiled by a normal C compiler. In the case of this project the compiler will be wrapped by the NVidia C Compiler (\textit{nvcc}), as the code generated will be include CUDA, so the generated CUDA code must also be valid.
The code will also need to actually invoke the JIT compiler as part of execution.
\par
The resulting executable compiled from the generated code must produce an output within some tolerance of executing parallel loop iterations in an arbitrary sequential order. OP2 makes an important restriction that the order in which elements are processed must not affect the final result, to within the limits of finite precision floating-point arithmetic\cite[p3]{op2main}, for example through data dependencies. This constraint allows the code generator freedom to not consider the ordering of iterations, and select an ordering based on performance. As with all compilers, correctness will always be a priority over performance.
\par
Finally, some OP2 API functions may need to be implemented differently to provide code that will make assertions based on the inputs at run-time. It will be ensured that the OP2 API itself is not be altered by any modifications to the library, to ensure that any and all exisiting programs using the API are able to seemless use the updated version.

\subsection{Run-time Assertions}
The application's input will be an unstructured mesh over which to operate, made up of a large amount of data points. The optimisation that will be made for this project is "Constant Definition", which is turning values specified in the input as constants into \verb|#define| directives for the C-Preprocessor in the recompiled code. Other possible optimisations will be discussed in Section \ref{ss:fw} (Future Work).

\subsection{System Model}
Figure \ref{fig:jit_sys} describes the new workflow of the OP2 library, with the addition of Just-In-Time compilation. As before, code generation takes the application and loop files as input, and generates the Kernels and Modified Application Files. It also generates Optimised Kernels, where the code will only be compiled once the constants are known, and defined for the pre-processor as literal values. These Kernel files are not known to the ahead of time compiler.
\\\noindent
The OP2 API function:
\codeline{void op_decl_const(int dim, char *type, T *dat, char *name)}{\cite[p9]{manual}}
Will be modified so that when called by the Program Binary it will generate a header file, where each of the constant values is added as a C \verb|#define| directive, where previously it needed to copy these values to the GPU device's memory.
\par
At run-time, the executable invokes the \textit{nvcc} compiler again, to compile the Optimised Kernels which semantically include the constants header file, and link them into a Shared Object (Dynamically Loaded Library). This object is then loaded by the running executable, and the functions it provides are used instead of the unoptimised versions.
\begin{figure}[h!]
\caption{OP2 System Diagram with JIT Addition}
\label{fig:jit_sys}
\makebox[\textwidth][c]{
\resizebox{1.2\textwidth}{!}{
  \begin{tikzpicture}[node distance=4cm, auto]
    \node [file] (source) {Source Files};
    \node [block, below of=source] (op2py) {CodeGen script};
    \node [file, right of=op2py, text width=6em] (sourceOp) {Modified Application Files};
    \node [file, above of=sourceOp] (Kernels) {Kernels};
    \node [file, below of=sourceOp] (recKernels) {Optimised Kernels};
    \node [wblock, right of=sourceOp] (aot) {AOT Compiler};
    \node [wfile, below of=aot] (op2lib) {OP2 Library Files};

    \node [rbin, right of=aot] (binary) {Program Binary};
    \node [rfile, above of=binary] (input) {Input Map};
    \node [jfile, below of=binary] (consts) {Constants};
    \node [jblock, below of=consts] (jit) {JIT Compiler};
    \node [jbin, right of= consts] (so) {Shared Object};
    \node [rblock, right of=binary] (result) {Program Result};

    \tikzset{dotted box1/.style={draw=black!100, line width=2pt, dash pattern=on 4pt off 4pt,
      inner sep=8mm, rectangle, rounded corners}};
    \tikzset{dotted box2/.style={draw=black!100, line width=2pt, dash pattern=on 4pt off 4pt,
      inner sep=6mm, rectangle, rounded corners}};

    \node (run-time) [dotted box1, fit = (input) (jit) (result), color=green!50!black] {};
    \node (jitbox) [dotted box2, fit = (recKernels) (so) (jit), color=red!50!black] {};

    \node at (run-time.north east) [above left=2mm] (rtbox) {\textbf{Run-time}};
    \node at (jitbox.south west) [below right=2mm] (corner) {\textbf{OP2 "JIT"}};

    \node (code-gen) [dotted box1, fit = (source) (recKernels), color=blue!50!black] {};
    \node at (code-gen.north west) [above right=2mm] (rtbox) {\textbf{Code Generation}};

    \path [line,line width=2pt, color=blue!50!black] (source) -- (op2py);
    \path [line, line width=2pt, color=blue!50!black] (op2py) -- (recKernels);
    \path [line, line width=2pt, color=blue!50!black] (op2py) -- (sourceOp);
    \path [line, line width=2pt, color=blue!50!black] (op2py) -- (Kernels);
    \path [line,line width=2pt, color=blue!50!black] (sourceOp) -- (aot);
    \path [line,line width=2pt, color=blue!50!black] (Kernels) -- (aot);
    \path [line,line width=2pt, color=black] (op2lib) -- (aot);
    \path [line,line width=2pt, color=red!70!black] (op2lib) -- (jit);
    \path [line, line width=2pt, color=green!50!black] (aot) -- (binary);
    \path [line,line width=2pt, color=green!50!black] (input) -- (binary);
    \path [line,line width=2pt, color=green!50!black] (binary) -- (consts);
    \path [line,line width=2pt, color=red!70!black] (recKernels) |- (jit);
    \path [line,line width=2pt, color=green!50!black] (consts) -- (jit);
    \path [line, line width=2pt, color=green!50!black] (jit) -| (so);
    \path [line,line width=2pt, color=green!50!black] (so) -- (binary);
    \path [line, line width=2pt, color=green!50!black] (binary) -- (result);

  \end{tikzpicture}
  }}
\end{figure}
