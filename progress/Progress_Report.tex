\documentclass[11pt]{article}

\usepackage{../styles/arxiv}

\usepackage{../styles/pgfgantt}
\usepackage{../styles/bibtopic}

\usepackage{setspace}

\renewcommand{\baselinestretch}{1.333}

\newcommand{\undertitle}{Progress Report}

\title{Extending Just-in-Time Compilation for OP2}

\author{Nathan Dunne - u1604486}

\begin{document}
\maketitle

\section*{Introduction}
The aim of this project is to contribute to the OP2 open-source project, an Embedded Domain Specific Langauge for describing unstructured mesh based applications. It provides an abstraction from the hardware to allow hardware specific performance benefits, such as SIMD vectorisation and GPU high levels of parallelism, to be gained without the programmer needing to understand the latest implementations, as well as allowing portability between different systems. The API has the added benefit of only having to update OP2 to include support for the newest hardware optimisations, and all applications written using it will be able to benefit.
\par On top of the existing work, there is space for greater performance to be gained through the use of Just-In-Time compilation: re-compiling the source code at run-time once the parameters are known, to allow expensive operations to be replaced with static constants where possible. This can provide significant benefit, especially over a large number of iterations as a small improvement can compound to better offset the one-time cost of the re-compilation. The sequential implementation has already been done, so the primary goal is to target the NVida GPU architecture using cuda, attempting to reach a performance improvement over Ahead-of-Time compiled cuda generation.
\par Since the OP2 API is in use, and the API itself will not be modified by the project, existing applications can be used to benchmark performance. Primarily this will be airfoil, an industrially representative computational fluid dynamics (CFD) program.
\subsection*{Motivations}
The motivations behind this project are a desire to use and expand on knowledge of optimisations and high-performance computing gained in the second year \textit{Advanced Computer Architecture} module, as well as an interest in compilers and code generation. It will also be personally beneficial to gain experience contributing to a real open-source project, with an existing code bae to deal with. It is gratifying to know that if the project is completed to a high standard, it could be merged into the master branch and used beyond the submission for a module.
\section*{Research}
In order to begin contributing to the OP2 I needed to build an understanding of the existing work. There are 2 main sources for this information:
\begin{itemize}
 \item{Papers publish on the OP2 website}
 \item{Analysis of existing source code}
\end{itemize}
While academic papers are useful to understand the context of the project and the motivations behind it; the existing code gives a more concrete understanding of the implementation, and the form my contributions will take. Understanding the basic structure of an OP2 program, where data is divided into sets and mappings between them - and loops can be defined as a seperate "kernel" of operations, is critical to making a useful contribution. 
\par There is a significant amount of literature already on performance engineering for GPUs, so it will mostly be a case of implementing the theory rather than investigating the possibility of performance benefit from further parallelism. The case for Just-In-Time compilation is made by its applications for performance from Java to LLVM.
\par 
\section*{Technical Content}
As well as the research above, the following work has been completed so far.
\subsection*{Prerequisites}
OP2 utilises two well established parallel mesh partitioning libraries: ParMetis and PT-Scotch. As I intend to work mainly on my personal laptop, a version of each had to be retrieved and built with the correct build arguments. The work with cuda also required the NVidia toolkit and drivers for the Nvidia MX250 card I have available. Finally, the airfoil example application makes use of HDF5 file I/O operations, so a build of that library was required as well. 

\subsection*{CUDA familiarity}
Since the cuda c++ api is not something I have used before, I experimented with writing small programs to run on a gpu, as well as referencing the \textit{Nvidia CUDA C Programming Guide} to build my Understanding. Knowledge of how cuda programs can solve common problems in parallelism, such as local and global shared memory, and the use of \textit{syncthreads()} will undoubtably be necessary to complete this project.

\subsection*{Hardware Resource}
The graphics card in my personal laptop is sufficent to execute the generated cuda code, and ensure correctness, however the system will be too noisy to gather representative benchmarks. To this end, I applied for and have been granted access to the Orac Hight Performance Computing node in the department, which will be used only for benchmarking.

\subsection*{Existing code familiarity}
The existing JIT work was done in the branch \textit{lazy-execution} of the Git repository. In order to extend this work, I've rebased the branch onto the master branch in order to benefit from the many changes commited to master since they diverged. 
\par Once this was done, I could begin to understand what the existing code does and how my code fits in. I was already aware that the bulk of my work will be done in the "translator" folder, with C as the target and python as the script language. Starting here with the main \textit{op2.py} script makes sense. This script parses the input file for API calls such as \textit{op\_decl\_set()}, \textit{op\_decl\_const}, and \textit{op\_par\_loop()}; for declaring sets, constants and loops respectively. These are sections that will need to be replaced for a normal compiler to accept them.
\par Each one is checked to be well formed, and the information described in their parameters recorded. This is especially important for loops, where the number of arguments and the type of each argument is defined, as well as whether it is optional, and stored in the list of "kernels". In order to be valid, each kernel must also have a definition of the operations to perform on each iteration, which for the example application \textit{airfoil} is a seperate header file of the same name, but this is not required.
\par The original input file is then written out, with declarations for functions representin each loop with the right number of parameters, and in the place of the loops: calls to these function. The definitions will be generated by the code generation scripts. 
\par op2.py then calls each codegen script for all the supported backends, to generate a folder for each backend containing the generated code. For JIT, initially only op2\_gen\_seq\_jit existed, so my contribution will be to populate this list of code generators similar to the Ahead-of-Time list. The reason for all this analysis of the op2.py script, is to understand the state of the file when the code I write is called, and the parameters that it will recieve:
\begin{enumerate}
\item{masterFile: the name of the first file passed to op2.py}
\item{date: the date today}
\item{consts: master list of declared constants in source file}
\item{kernels: master list of loop kernels declared in source file}
\end{enumerate}
The code generator can then loop through the kernels, and generate a function to call for each one based on the target hardware.

\subsection*{Implementation}
At time of writing the implementation of cuda JIT code generation has just started. The op2.py script has been modified to call a cuda\_jit code generation file, and added to the makefile of airfoil to include an airfoil\_cuda\_jit entry, however the codegeneration itself is still sequential. To complete the cuda JIT implentation I will use the AoT cuda implementation as a guide to speed up the process.

\section*{Timetable}
\newcommand\w{25}
\begin{figure}[h!]
\centering
\makebox[0pt]{
\begin{ganttchart}[
expand chart=1.22\textwidth,
vgrid={*3{white},*1{dotted}, *{14}{white}, *1{dotted}, *1{white}, *1{dotted}, *5{white}},
hgrid=true,
y unit chart=0.8cm,
inline,
today=6,
today label=Expected Progress,
today label font=\itshape,
]{0}{\w}

 \gantttitle{Timeline}{26} \\
 \gantttitlelist{0,...,\w}{1} \\

 \ganttgroup{Research}{1}{3} \\ %0%
 
 \ganttset{inline=false}
 \ganttbar{Read Papers}{1}{2}          %1%
 \ganttset{inline=true}

 \ganttgroup{Implementation}{4}{18} \\ %2%

 \ganttset{inline=false}
 \ganttbar{Familiarity Work}{2}{3}     %3%
 \ganttset{inline=true}

 \ganttgroup{Benchmarking}{19}{20} \\  %4%

 \ganttset{inline=false} 
 \ganttbar{Feature Development}{4}{5}  %5%
 \ganttbar{} {7}{8}                   %6%
 \ganttbar{} {10}{11}                  %7%
 \ganttbar{} {13}{14}                  %8%
 \ganttbar{} {16}{17}                  %9%
 \ganttset{inline=true}
 \ganttgroup{Documentation}{21}{25} \\ %10%

 \ganttset{inline=false} 

 \ganttbar{Feature Testing}{6}{6}      %11%
 \ganttbar{}{9}{9}                   %12%
 \ganttbar{}{12}{12}                   %13%
 \ganttbar{}{15}{15}                   %14%
 \ganttbar{}{18}{18}                   %15%

\\
 
 \ganttbar{Results Gathering}{19}{19}  %16%
 \\
 \ganttbar{Results Processing}{19}{20} %17%
 \\  
 
 \ganttbar{Final Report}{21}{25} \\    %18
 \ganttbar{Presentation}{21}{22}       %19

 \ganttlink{elem3}{elem5}
 \ganttlink{elem5}{elem11}
 \ganttlink{elem11}{elem6}
 \ganttlink{elem6}{elem12}
 \ganttlink{elem12}{elem7}
 \ganttlink{elem7}{elem13}
 \ganttlink{elem13}{elem8}
 \ganttlink{elem8}{elem14}
 \ganttlink{elem14}{elem9}
 \ganttlink{elem9}{elem15}
 \ganttlink{elem15}{elem16}
 \ganttset{link mid=0.25}
 \ganttlink{elem15}{elem17}
 \ganttset{link mid=0.5}
 \ganttlink{elem17}{elem18}
 \ganttset{link mid=0.25}
 \ganttlink{elem17}{elem19}
 \ganttset{link mid=0.5}
 \ganttlink{elem1}{elem3}
\end{ganttchart}
}
\caption{Original Timetable}
\label{fig:orig}
\end{figure}
The timetable from the project specification (Figure \ref{fig:orig}) shows the expected level of progress at this stage. It is clear that the project has not run quite to time. While I am still confident that the cuda JIT code generation can be done by the end of the 8th week of the project, implementations of 2 weeks simply doesn't provide sufficient time to produce something work benchmarking. Therefore, I have reworked the timetable to three iterations of four weeks implementation and one testing, rather than five rounds of 3 week blocks (Figure \ref{fig:new}).
\par As well as aligning with the end of the Autumn term, this also allows for two more weeks development of time overall.

\begin{figure}[h!]
\centering
\makebox[0pt]{
\begin{ganttchart}[
expand chart=1.22\textwidth,
vgrid={*3{white},*1{dotted}, *{14}{white}, *1{dotted}, *1{white}, *1{dotted}, *5{white}},
hgrid=true,
y unit chart=0.8cm,
inline,
today=6,
today label=Expected Progress,
today label font=\itshape,
]{0}{\w}

 \gantttitle{Timeline}{26} \\
 \gantttitlelist{0,...,\w}{1} \\

 \ganttgroup{Research}{1}{3} \\ %0%
 
 \ganttset{inline=false}
 \ganttbar{Read Papers}{1}{2}          %1%
 \ganttset{inline=true}

 \ganttgroup{Implementation}{4}{18} \\ %2%

 \ganttset{inline=false}
 \ganttbar{Familiarity Work}{2}{3}     %3%
 \ganttset{inline=true}

 \ganttgroup{Benchmarking}{19}{20} \\  %4%

 \ganttset{inline=false} 
 \ganttbar{Feature Development}{4}{7}  %5%
 \ganttbar{} {9}{12}                   %6%
 \ganttbar{} {14}{17}                  %7%
 \ganttset{inline=true}
 \ganttgroup{Documentation}{21}{25} \\ %8%

 \ganttset{inline=false} 

 \ganttbar{Feature Testing}{8}{8}      %9%
 \ganttbar{}{13}{13}                   %10%
 \ganttbar{}{18}{18}                   %11%

\\
 
 \ganttbar{Results Gathering}{19}{19}  %12%
 \\
 \ganttbar{Results Processing}{19}{20} %13%
 \\  
 
 \ganttbar{Final Report}{21}{25} \\    %14
 \ganttbar{Presentation}{21}{22}       %15

 \ganttlink{elem1}{elem3}
 \ganttlink{elem3}{elem5}
 \ganttlink{elem5}{elem9}
 \ganttlink{elem9}{elem6}
 \ganttlink{elem6}{elem10}
 \ganttlink{elem10}{elem7}
 \ganttlink{elem7}{elem11}
 \ganttlink{elem11}{elem12}
 \ganttset{link mid=0.25}
 \ganttlink{elem11}{elem13}
 \ganttset{link mid=0.5}
 \ganttlink{elem13}{elem14}
 \ganttset{link mid=0.25}
 \ganttlink{elem13}{elem15}
 \ganttset{link mid=0.5}
\end{ganttchart}
}
\caption{Modified Timetable}
\label{fig:new}
\end{figure}
\section*{Reflection}

\section*{Ethics}

\section*{Project Management}

\bibliographystyle{plain}
\clearpage
\begin{btSect}{progress}
\section**{References}
\btPrintCited
\section**{Further Reading}
\btPrintNotCited
\end{btSect}
\end{document}

